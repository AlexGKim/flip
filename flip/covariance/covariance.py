import time

import numpy as np

from flip.covariance import contraction as contraction_flip
from flip.covariance import cov_utils
from flip.covariance import generator as generator_flip
from flip.covariance.adamsblake17plane import (
    coefficients as coefficients_adamsblake17plane,
)
from flip.covariance.adamsblake17plane import generator as generator_adamsblake17plane
from flip.covariance.adamsblake20 import coefficients as coefficients_adamsblake20
from flip.covariance.carreres23 import coefficients as coefficients_carreres23
from flip.covariance.carreres23 import generator as generator_carreres23
from flip.covariance.lai22 import coefficients as coefficients_lai22
from flip.covariance.lai22 import generator as generator_lai22
from flip.covariance.ravouxcarreres import coefficients as coefficients_ravouxcarreres
from flip.utils import create_log

log = create_log()


class CovMatrix:
    def __init__(
        self,
        model_name=None,
        model_type=None,
        los_definition=None,
        covariance_dict=None,
        full_matrix=False,
        number_densities=None,
        number_velocities=None,
        contraction_covariance_dict=None,
        contraction_coordinates_dict=None,
        contraction_los_definition=None,
    ):
        """
        The __init__ function is called when the class is instantiated.
        It sets up the instance of the class, and defines all of its attributes.


        Args:
            self: Represent the instance of the class
            model_name: Identify the model
            model_type: Define the type of model that is being used
            los_definition: Define the angle between two vectors
            covariance_dict: Store the covariance matrix
            full_matrix: Determine whether the covariance matrix is stored as a full matrix or in sparse form
            number_densities: Set the number of density variables in the model
            number_velocities: Set the number of velocities in the model
            contraction_covariance_dict: Store the contraction
            contraction_coordinates_dict: Define the coordinates of the contraction
            : Define the model name

        Returns:
            An object of the class
        """

        self.model_name = model_name
        self.model_type = model_type
        self.los_definition = los_definition
        self.covariance_dict = covariance_dict
        self.full_matrix = full_matrix
        self.number_densities = number_densities
        self.number_velocities = number_velocities
        self.contraction_covariance_dict = contraction_covariance_dict
        self.contraction_coordinates_dict = contraction_coordinates_dict
        self.contraction_los_definition = contraction_los_definition

    @classmethod
    def init_from_flip(
        cls,
        model_name,
        model_type,
        power_spectrum_dict,
        coordinates_density=None,
        coordinates_velocity=None,
        additional_parameters_values=None,
        los_definition="bisector",
        **kwargs,
    ):
        """
        The init_from_flip function is a function that initializes the covariance matrix from the flip code.
        It takes as input:
            - model_name: name of the model used to generate the covariance matrix (e.g., 'lai22')
            - model_type: type of data used to generate the covariance matrix (e.g., 'density' or 'velocity')
            - power_spectrum_dict: dictionary containing all information about power spectrum, including k and P(k) values, redshift, etc...
                It is generated by calling getPowerSpectrumDict() in

        Args:
            cls: Indicate that the function is a class method
            model_name: Determine which model to use for the covariance matrix
            model_type: Determine the type of model to be used
            power_spectrum_dict: Pass the power spectrum of the model
            coordinates_density: Specify the coordinates of the density field
            coordinates_velocity: Define the velocity coordinates of the covariance matrix
            additional_parameters_values: Pass the values of additional parameters to the flip code
            **kwargs: Pass a variable number of keyword arguments to the function
            : Generate the covariance matrix from a flip model

        Returns:
            A covariancematrix object

        """
        begin = time.time()
        (
            covariance_dict,
            number_densities,
            number_velocities,
        ) = generator_flip.generate_covariance(
            model_name,
            model_type,
            power_spectrum_dict,
            coordinates_density=coordinates_density,
            coordinates_velocity=coordinates_velocity,
            additional_parameters_values=additional_parameters_values,
            los_definition=los_definition,
            **kwargs,
        )
        end = time.time()
        log.add(
            f"Covariance matrix generated from flip with {model_name} model in {'{:.2e}'.format(end - begin)} seconds"
        )
        return cls(
            model_name=model_name,
            model_type=model_type,
            covariance_dict=covariance_dict,
            number_densities=number_densities,
            number_velocities=number_velocities,
            full_matrix=False,
            los_definition=los_definition,
        )

    @classmethod
    def init_from_generator(
        cls,
        model_name,
        model_type,
        power_spectrum_dict,
        coordinates_velocity=None,
        coordinates_density=None,
        additional_parameters_values=None,
        **kwargs,
    ):
        """
        The init_from_generator function is a helper function that allows the user to initialize
        a Covariance object from a generator. The init_from_generator function takes in as arguments:
            - cls: the class of the object being initialized (Covariance)
            - model_name: name of covariance model used to generate covariance matrix (e.g., 'lai22')
            - model_type: type of covariance matrix generated ('density' or 'velocity')
            - power spectrum dictionary containing keys for each redshift bin and values corresponding to
                power spectra at those red

        Args:
            cls: Refer to the class itself
            model_name: Specify the type of model used to generate the covariance matrix
            model_type: Determine which model to use
            power_spectrum_dict: Pass the power spectrum to the generate_* functions
            coordinates_velocity: Generate the velocity covariance matrix
            coordinates_density: Generate the density field
            additional_parameters_values: Pass additional parameters to the generator function
            **kwargs: Pass a variable number of keyword arguments to the function
            : Generate the covariance matrix from a given model

        Returns:
            An object of the class covariancematrix

        """
        begin = time.time()
        covariance_dict, number_densities, number_velocities, los_definition = eval(
            f"generator_{model_name}.generate_covariance"
        )(
            model_type,
            power_spectrum_dict,
            coordinates_density=coordinates_density,
            coordinates_velocity=coordinates_velocity,
            **kwargs,
        )
        end = time.time()
        log.add(
            f"Covariance matrix generated from {model_name} model in {'{:.2e}'.format(end - begin)} seconds"
        )
        return cls(
            model_name=model_name,
            model_type=model_type,
            covariance_dict=covariance_dict,
            number_densities=number_densities,
            number_velocities=number_velocities,
            full_matrix=False,
            los_definition=los_definition,
        )

    @classmethod
    def init_from_file(
        cls,
        model_name,
        model_type,
        filename,
    ):
        """
        The init_from_file function is used to initialize a model from a file.

        Args:
            cls: Create a new instance of the class
            model_name: Name the model
            model_type: Determine the type of model to be created
            filename: Specify the file to read from
            : Specify the name of the model

        Returns:
            A tuple of the model and a list of

        """
        log.add(f"Reading from filename not implemented yet")

    @classmethod
    def init_contraction_from_flip(
        cls,
        model_name,
        model_type,
        power_spectrum_dict,
        r_perpendicular,
        r_parallel,
        r_reference,
        additional_parameters_values=None,
        los_definition="bisector",
        **kwargs,
    ):
        """
        The init_contraction_from_flip function is a class method that initializes the contraction_covariance_dict and
        contraction_coordinates_dict attributes of the Contraction object. The init_contraction function calls this function, which
        in turn calls contract_flip to generate these attributes. This allows us to use the same code for both initialization
        and contraction.

        Args:
            cls: Refer to the class that is being instantiated
            model_name: Name the model
            model_type: Determine the type of model to be used
            power_spectrum_dict: Pass the power spectrum of the model
            r_perpendicular: Define the perpendicular distance from the observer to a point in space
            r_parallel: Define the parallel direction of the contraction
            r_reference: Set the reference scale for the contraction
            additional_parameters_values: Pass in the values of additional parameters
            **kwargs: Pass keyworded, variable-length argument list
            : Create a new instance of the class

        Returns:
            An instance of the contraction class
        """
        (
            contraction_covariance_dict,
            contraction_coordinates_dict,
        ) = contraction_flip.contract_covariance(
            model_name,
            model_type,
            power_spectrum_dict,
            r_perpendicular,
            r_parallel,
            r_reference,
            additional_parameters_values=additional_parameters_values,
            los_definition=los_definition,
            **kwargs,
        )

        return cls(
            model_name=model_name,
            model_type=model_type,
            contraction_covariance_dict=contraction_covariance_dict,
            contraction_coordinates_dict=contraction_coordinates_dict,
            contraction_los_definition=los_definition,
        )

    @property
    def type(self):
        """
        The type function is used to determine the type of covariance model that will be computed.
        The options are:
            - velocity: The covariance model is computed for velocity only.
            - density: The covariance model is computed for density only.
            - density_velocity: The covariance model is computed for both velocity and density, without cross-term (i.e., the covariances between velocities and densities are zero). This option should be used when computing a full 3D tomography in which we want to compute a separate 1D tomography along each axis (x, y, z

        Args:
            self: Represent the instance of the class

        Returns:
            The type of the model

        """
        if self.model_type == "velocity":
            log.add("The covariance model is computed for velocity")
        elif self.model_type == "density":
            log.add("The covariance model is computed for density")
        elif self.model_type == "density_velocity":
            log.add(
                "The covariance model is computed for velocity and density, without cross-term"
            )
        elif self.model_type == "full":
            log.add(
                "The covariance model is computed for velocity and density, with cross-term"
            )
        return self.model_type

    @property
    def loaded(self):
        """
        The loaded function checks if the covariance matrix is loaded.

        Args:
            self: Refer to the object itself

        Returns:
            A boolean

        """
        if self.model_type == "density":
            if "gg" in self.covariance_dict.keys():
                return True
            else:
                return False
        elif self.model_type == "velocity":
            if "vv" in self.covariance_dict.keys():
                return True
            else:
                return False
        elif self.model_type == "density_velocity":
            if ("vv" in self.covariance_dict.keys()) & (
                "gg" in self.covariance_dict.keys()
            ):
                return True
            else:
                return False
        elif self.model_type == "full":
            if (
                ("vv" in self.covariance_dict.keys())
                & ("gg" in self.covariance_dict.keys())
                & ("gv" in self.covariance_dict.keys())
            ):
                return True
            else:
                return False
        else:
            log.add("The model type was not found")
            return False

    def compute_covariance_sum(
        self,
        parameter_values_dict,
        vector_err,
    ):
        """
        The compute_covariance_sum function computes the sum of all covariance matrices
            and adds the diagonal terms.

        Args:
            self: Access the attributes of the class
            parameter_values_dict: Pass the values of the parameters
            : Compute the covariance matrix

        Returns:
            The sum of the covariance matrices with their respective coefficients

        """
        coefficients_dict = eval(f"coefficients_{self.model_name}.get_coefficients")(
            self.model_type,
            parameter_values_dict,
        )
        coefficients_dict_diagonal = eval(
            f"coefficients_{self.model_name}.get_diagonal_coefficients"
        )(
            self.model_type,
            parameter_values_dict,
        )

        if self.model_type == "density":
            covariance_sum = np.sum(
                [
                    coefficients_dict["gg"][i] * cov
                    for i, cov in enumerate(self.covariance_dict["gg"])
                ],
                axis=0,
            )
            covariance_sum += np.diag(
                coefficients_dict_diagonal["gg"] + vector_err**2
            )

        elif self.model_type == "velocity":
            covariance_sum = np.sum(
                [
                    coefficients_dict["vv"][i] * cov
                    for i, cov in enumerate(self.covariance_dict["vv"])
                ],
                axis=0,
            )

            covariance_sum += np.diag(
                coefficients_dict_diagonal["vv"] + vector_err**2
            )

        elif self.model_type in ["density_velocity", "full"]:
            number_densities = self.number_densities
            number_velocities = self.number_velocities
            density_err = vector_err[:number_densities]
            velocity_err = vector_err[
                number_densities : number_densities + number_velocities
            ]

            if self.model_type == "density_velocity":
                covariance_sum_gv = np.zeros((number_densities, number_velocities))
            elif self.model_type == "full":
                covariance_sum_gv = np.sum(
                    [
                        coefficients_dict["gv"][i] * cov
                        for i, cov in enumerate(self.covariance_dict["gv"])
                    ],
                    axis=0,
                )
            covariance_sum_gg = np.sum(
                [
                    coefficients_dict["gg"][i] * cov
                    for i, cov in enumerate(self.covariance_dict["gg"])
                ],
                axis=0,
            )
            covariance_sum_gg += np.diag(
                coefficients_dict_diagonal["gg"] + density_err**2
            )

            covariance_sum_vv = np.sum(
                [
                    coefficients_dict["vv"][i] * cov
                    for i, cov in enumerate(self.covariance_dict["vv"])
                ],
                axis=0,
            )

            covariance_sum_vv += np.diag(
                coefficients_dict_diagonal["vv"] + velocity_err**2
            )

            covariance_sum = np.block(
                [
                    [covariance_sum_gg, covariance_sum_gv],
                    [covariance_sum_gv.T, covariance_sum_vv],
                ]
            )
        else:
            log.add(f"Wrong model type in the loaded covariance.")

        return covariance_sum

    def compute_contraction_sum(
        self,
        parameter_values_dict,
    ):
        """
        The compute_contraction_sum function computes the sum of all the contractions
            for a given model type and parameter values.

        Args:
            self: Make the function a method of the class
            parameter_values_dict: Get the coefficients for each of the covariances
            : Get the coefficients of the model

        Returns:
            A dictionary of contraction_covariance_sum
        """
        coefficients_dict = eval(f"coefficients_{self.model_name}.get_coefficients")(
            self.model_type,
            parameter_values_dict,
        )
        contraction_covariance_sum_dict = {}
        if self.model_type == "density":
            contraction_covariance_sum_dict["gg"] = np.sum(
                [
                    coefficients_dict["gg"][i] * cov
                    for i, cov in enumerate(self.contraction_covariance_dict["gg"])
                ],
                axis=0,
            )

        elif self.model_type == "velocity":
            contraction_covariance_sum_dict["vv"] = np.sum(
                [
                    coefficients_dict["vv"][i] * cov
                    for i, cov in enumerate(self.contraction_covariance_dict["vv"])
                ],
                axis=0,
            )

        elif self.model_type in ["density_velocity", "full"]:
            if self.model_type == "full":
                contraction_covariance_sum_dict["gv"] = np.sum(
                    [
                        coefficients_dict["gv"][i] * cov
                        for i, cov in enumerate(self.contraction_covariance_dict["gv"])
                    ],
                    axis=0,
                )
            contraction_covariance_sum_dict["gg"] = np.sum(
                [
                    coefficients_dict["gg"][i] * cov
                    for i, cov in enumerate(self.contraction_covariance_dict["gg"])
                ],
                axis=0,
            )

            contraction_covariance_sum_dict["vv"] = np.sum(
                [
                    coefficients_dict["vv"][i] * cov
                    for i, cov in enumerate(self.contraction_covariance_dict["vv"])
                ],
                axis=0,
            )
        else:
            log.add(f"Wrong model type in the loaded covariance.")

        return contraction_covariance_sum_dict

    def compute_covariance_sum_eigenvalues(
        self,
        parameter_values_dict,
        vector_err,
    ):
        covariance_sum = self.compute_covariance_sum(
            parameter_values_dict,
            vector_err,
        )
        return np.linalg.eigvals(covariance_sum)

    def compute_full_matrix(self):
        """
        The compute_full_matrix function takes the covariance matrix and fills in all of the missing values.

        Args:
            self: Bind the method to the object

        Returns:
            A dictionary with the full covariance matrices for each redshift bin

        Doc Author:
            Trelent
        """
        if self.full_matrix is False:
            for key in ["gg", "vv", "gv"]:
                if key in self.covariance_dict.keys():
                    if key == "gg":
                        new_shape = (
                            self.covariance_dict[key].shape[0],
                            self.number_densities,
                            self.number_densities,
                        )
                    elif key == "gv":
                        new_shape = (
                            self.covariance_dict[key].shape[0],
                            self.number_densities,
                            self.number_velocities,
                        )
                    elif key == "vv":
                        new_shape = (
                            self.covariance_dict[key].shape[0],
                            self.number_velocities,
                            self.number_velocities,
                        )
                    new_cov = np.zeros(new_shape)
                    for i, _ in enumerate(self.covariance_dict[key]):
                        if key == "gv":
                            new_cov[i] = cov_utils.return_full_cov_cross(
                                self.covariance_dict[key][i],
                                self.number_densities,
                                self.number_velocities,
                            )
                        else:
                            new_cov[i] = cov_utils.return_full_cov(
                                self.covariance_dict[key][i]
                            )
                    self.covariance_dict[key] = new_cov

            self.full_matrix = True

    def write(
        self,
        filename,
    ):
        """
        The write function writes the covariance matrix to a file.

        Args:
            self: Represent the instance of the class
            filename: Specify the name of the file to be written
            : Specify the name of the file in which we want to save our covariance matrix

        Returns:
            Nothing

        """
        np.savez(filename, **self.covariance_dict)
        log.add(f"Cov written in {filename}.")
